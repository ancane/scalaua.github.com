<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <title>ScalaUA: Developing arithmetic in Gödel's system T</title>
    
    <link rel="stylesheet" href="../css/main.css">
    
    <link rel="alternate" type="application/atom+xml" href="../articles.atom" title="Extralogical feed">

<!--tracking-->
</head><body>
    <header id="header"><div class="wrapper">
        <h1 id="title"><a href="../">Scala в Украине</a></h1>
        
        <ul id="navigation">
            <li><a href="../meetups">Встречи</a></li>
            <li><a href="../articles">Архив</a></li>
            <li><a href="../about">О Скале</a></li>
        </ul>
    </div></header>
    
    <section id="main" class="wrapper">
        <article>
    <h1>Developing arithmetic in Gödel's system T</h1>
    
    <p class="date">April 11, 2011</p>
    
    <p>This year I’ve been running a reading group on type theory. Our primary text is <a href="http://www.PaulTaylor.EU/stable/Proofs+Types.html"><em>Proofs and Types</em></a> by Jean-Yves Girard, Yves Lafont and Paul Taylor. The focus of the book is the development of the typed λ-calculus, with a strong proof-theoretic slant, these two perspectives being unified by the <a href="http://en.wikipedia.org/wiki/Curry–Howard_correspondence">Curry-Howard correspondence</a>. It begins by exploring the connections between <a href="http://en.wikipedia.org/wiki/Intuitionistic_logic">intuitionistic logic</a> and the <a href="http://en.wikipedia.org/wiki/Simply_typed_lambda_calculus">simply typed lambda calculus</a>, and works up to a fairly in-depth study of <a href="http://en.wikipedia.org/wiki/System_F">System F</a>.</p>
<p>One of the intermediate steps is the system <em>T</em>, originally developed by Kurt Gödel in his <a href="http://en.wikipedia.org/wiki/Dialectica_interpretation">Dialectica interpretation</a>, and reformulated by Tait in 1967. I won’t try to cover the history here—there are plenty of articles out there if you’re interested. (The names of the articles alluded to are given in the references at the end.)</p>
<p>The modern formulation of <em>T</em> is as a typed λ-calculus with natural number and boolean types. In chapter 7 of <em>Proofs and Types</em>, Girard shows how the natural numbers can be represented in <em>T</em>, and provides a definition of addition based on the recursion operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">R</mtext></mrow></math>. He goes on to say that</p>
<blockquote>
<p>Among easy exercises in this style, one can amuse oneself by defining multiplication, exponenential, predecessor <em>etc.</em></p>
</blockquote>
<p>So, let’s amuse ourselves! Thinking about these simple examples is helpful because it gives a working demonstration of how the recursion operator adds power back to the language which was lost when the restrictive type system was introduced.</p>
<p>For example, the untyped λ-calculus allows one to use <a href="http://en.wikipedia.org/wiki/Church_encoding">Church encoding</a> to represent the natural numbers, but in the simply typed lambda calculus one is barred from forming the relevant terms by the requirement that every term be well-typed.</p>
<p>During the reading group meeting where we discussed this chapter, we managed to assemble a working definition for multiplication, which I’ll present below along with the other arithmetical functions Girard suggests. However, before we get onto that, I’m going to briefly sketch how the type of natural numbers <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">Nat</mtext></mrow></math> is defined in <em>T</em>; the introduction and elimination rules for terms of that type, on which everything else is built; and how an addition function can be defined in terms of those rules.</p>
<p>A small niggle: Girard actually talks about an <em>integer type</em> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">Int</mtext></mrow></math>. When one examines the nature of the type it becomes clear that what’s intended is a natural number type, so I’m going to talk solely about natural numbers and call the type in question <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">Nat</mtext></mrow></math>, not <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">Int</mtext></mrow></math>.</p>
<h2 id="natural-numbers-in-t">Natural numbers in <em>T</em></h2>
<p>System <em>T</em> is a variant of the simply typed lambda calculus, so it has three sorts of rules: those stating which <em>types</em> exist; those stating which <em>terms</em> of those types can be formed; and reduction rules stating how some terms can be reduced to others. These are spelled out in §3.1 of <a href="http://www.PaulTaylor.EU/stable/Proofs+Types.html"><em>Proofs and Types</em></a>, so if any of the following doesn’t make sense, I recommend checking that out (the book is freely available from the link above).</p>
<p>For system <em>T</em>, there are also two constant types, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">Nat</mtext></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">Bool</mtext></mrow></math>; here we shall only be concerned with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">Nat</mtext></mrow></math> so I shall omit the rules mentioning <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">Bool</mtext></mrow></math>. The additional term formation rules for system <em>T</em> specify how one can introduce and eliminate terms of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">Nat</mtext></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">Bool</mtext></mrow></math>. The introduction rules are:</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">O</mtext></mrow></math> is a (constant) term of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">Nat</mtext></mrow></math>;</li>
<li>If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>t</mi></mrow></math> is a term of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">Nat</mtext></mrow></math>, then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">S</mtext><mi>t</mi></mrow></math> is a term of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">Nat</mtext></mrow></math>.</li>
</ul>
<p>These mirror their equivalents in Peano Arithmetic almost exactly—that is, they represent zero and the successor function. There is also the elimination rule for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">Nat</mtext></mrow></math>, which introduces the recursion operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">R</mtext></mrow></math>:</p>
<ul>
<li>If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>u</mi></mrow></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>v</mi></mrow></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>t</mi></mrow></math> are of types respectively <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>U</mi></mrow></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>U</mi><mo>→</mo><mo stretchy="false">(</mo><mtext mathvariant="sans-serif">Nat</mtext><mo>→</mo><mi>U</mi><mo stretchy="false">)</mo></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">Nat</mtext></mrow></math>, then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">R</mtext><mi>u</mi><mi>v</mi><mi>t</mi></mrow></math> is of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>U</mi></mrow></math>.</li>
</ul>
<p>The recursion operator allows us to combine the introduction rules to give recursive definitions of arithmetic operations such as addition and multiplication in a form not too far removed from their counterparts in Peano Arithmetic. Its reduction rule is given by two cases:</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">R</mtext><mi>u</mi><mi>v</mi><mtext mathvariant="sans-serif">O</mtext></mrow></math> reduces to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>u</mi></mrow></math>.</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">R</mtext><mi>u</mi><mi>v</mi><mo stretchy="false">(</mo><mtext mathvariant="sans-serif">S</mtext><mi>x</mi><mo stretchy="false">)</mo></mrow></math> reduces to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>v</mi><mo stretchy="false">(</mo><mtext mathvariant="sans-serif">R</mtext><mi>u</mi><mi>v</mi><mi>x</mi><mo stretchy="false">)</mo><mi>x</mi></mrow></math>.</li>
</ul>
<p>The first is the <em>base case</em>, which ensures that the recursion is well-founded. The second rule gives, for the recursive case, a way of eliminating an instance of the recursion operator. The term it reduces to looks more complex than the one we started with, but it’s clear that eventually we’re going to run out of successors and the reduction process will terminate (a proof of this is given in §7.2 of <em>Proofs and Types</em>).</p>
<h2 id="addition">Addition</h2>
<p>With the preamble out of the way, we’re finally ready to start defining the usual arithmetic functions within <em>T</em>. The easiest place to start is with the definition of addition.</p>
<blockquote>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>+</mo><mn>0</mn><mo>=</mo><mi>x</mi></mrow></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>+</mo><mi>S</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>S</mi><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></math></p>
</blockquote>
<p>There’s no recursion operator in sight in this definition, but of course there is recursion occurring. The first equation gives the base case, defining the result when the addition function is used to combine a number <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>0</mn></mrow></math>. The second equation defines the recursive case, giving the result when we add the successor of some number <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>y</mi></mrow></math> to some number <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math>. The recursion operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">R</mtext></mrow></math> has three arguments, and the first two map to these cases: the value of the base case (here it would be <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math>) and the function to apply in the recursive case (here, the successor function).</p>
<p>With this in mind, we can formulate an addition function in <em>T</em> pretty straightforwardly. The variables bound by lambda abstractions have been given type annotations, just to make clear how the types of these terms relate to those specified in the introduction and elimination rules for terms of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">Nat</mtext></mrow></math>. I shall omit these annotations from the definitions in the rest of the article.</p>
<blockquote>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">add</mtext><mo>=</mo><mi>λ</mi><mrow></mrow><msup><mi>x</mi><mtext mathvariant="sans-serif">Nat</mtext></msup><mo>.</mo><mi>λ</mi><mrow></mrow><msup><mi>y</mi><mtext mathvariant="sans-serif">Nat</mtext></msup><mo>.</mo><mtext mathvariant="sans-serif">R</mtext><mi>x</mi><mo stretchy="false">(</mo><mi>λ</mi><mrow></mrow><msup><mi>z</mi><mtext mathvariant="sans-serif">Nat</mtext></msup><mo>.</mo><mi>λ</mi><mrow></mrow><msup><mi>w</mi><mtext mathvariant="sans-serif">Nat</mtext></msup><mo>.</mo><mtext mathvariant="sans-serif">S</mtext><mi>z</mi><mo stretchy="false">)</mo><mi>y</mi></mrow></math></p>
</blockquote>
<p>The second term given to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">R</mtext></mrow></math> is just a double lambda abstraction over <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">S</mtext><mi>x</mi></mrow></math>, representing a two-argument function; the second argument (the numbers accumulating on the right of the reduction) will always be thrown away. The type of the term must be, by the definition we gave earlier, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>U</mi><mo>→</mo><mo stretchy="false">(</mo><mtext mathvariant="sans-serif">Nat</mtext><mo>→</mo><mi>U</mi><mo stretchy="false">)</mo></mrow></math>. In this case we’re saying that the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>U</mi></mrow></math> is in fact the constant type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">Nat</mtext></mrow></math>, so the term has a type of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">Nat</mtext><mo>→</mo><mo stretchy="false">(</mo><mtext mathvariant="sans-serif">Nat</mtext><mo>→</mo><mtext mathvariant="sans-serif">Nat</mtext><mo stretchy="false">)</mo></mrow></math>.</p>
<p>I should note that there is no mechanism in <em>T</em> for giving names to definitions (i.e. let binding), so equations like the one given above should simply be seen as expressing abbreviations, not as expressions in the language of <em>T</em>, although the lambda term on the right hand side certainly is.</p>
<h2 id="multiplication">Multiplication</h2>
<p>Again, let’s begin with the definition of multiplication we find in Peano Arithmetic.</p>
<blockquote>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>⋅</mo><mn>0</mn><mo>=</mo><mn>0</mn></mrow></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>⋅</mo><mi>S</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>⋅</mo><mi>y</mi><mo stretchy="false">)</mo><mo>+</mo><mi>y</mi></mrow></math></p>
</blockquote>
<p>Here we can see that in the base case, when we combine <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>0</mn></mrow></math> with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> the result is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>0</mn></mrow></math>. In contrast, in the base case for addition when we combine <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>0</mn></mrow></math> with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> the result is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math>. This is reflected in the following definition of multiplication in <em>T</em>, with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">O</mtext></mrow></math> as the base case, and <em>addition</em> as the operation applied in the successor case.</p>
<blockquote>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">mult</mtext><mo>=</mo><mi>λ</mi><mrow></mrow><mi>x</mi><mo>.</mo><mi>λ</mi><mrow></mrow><mi>y</mi><mo>.</mo><mtext mathvariant="sans-serif">RO</mtext><mo stretchy="false">(</mo><mi>λ</mi><mrow></mrow><mi>z</mi><mo>.</mo><mi>λ</mi><mrow></mrow><mi>w</mi><mo>.</mo><mo stretchy="false">(</mo><mtext mathvariant="sans-serif">add</mtext><mo stretchy="false">)</mo><mi>x</mi><mi>z</mi><mo stretchy="false">)</mo><mi>y</mi></mrow></math></p>
</blockquote>
<p>Expanding the definition of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">add</mtext></mrow></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">mult</mtext></mrow></math> (with some trivial α-conversion and β-reduction), it’s easy to see the double recursion that we also see in the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">PA</mtext></mrow></math> definitions.</p>
<blockquote>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">mult</mtext><mo>=</mo><mi>λ</mi><mrow></mrow><mi>x</mi><mo>.</mo><mi>λ</mi><mrow></mrow><mi>y</mi><mo>.</mo><mtext mathvariant="sans-serif">RO</mtext><mo stretchy="false">(</mo><mi>λ</mi><mrow></mrow><mi>z</mi><mo>.</mo><mi>λ</mi><mrow></mrow><mi>w</mi><mo>.</mo><mtext mathvariant="sans-serif">R</mtext><mi>x</mi><mo stretchy="false">(</mo><mi>λ</mi><mrow></mrow><mi>u</mi><mo>.</mo><mi>λ</mi><mrow></mrow><mi>v</mi><mo>.</mo><mtext mathvariant="sans-serif">S</mtext><mi>u</mi><mo stretchy="false">)</mo><mi>z</mi><mo stretchy="false">)</mo><mi>y</mi></mrow></math></p>
</blockquote>
<h2 id="exponentiation">Exponentiation</h2>
<p>Just as multiplication is built on addition, adding an extra layer of recursion, so exponentiation is built on multiplication. The <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">PA</mtext></mrow></math> equations are</p>
<blockquote>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msup><mi>x</mi><mn>0</mn></msup><mo>=</mo><mn>1</mn></mrow></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msup><mi>x</mi><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></msup><mo>=</mo><msup><mi>x</mi><mi>y</mi></msup><mo>⋅</mo><mi>y</mi></mrow></math></p>
</blockquote>
<p>Again, all we need to do to define this new function is state the base case (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">SO</mtext></mrow></math>, corresponding to the rule that any number raised to exponent 0 is 1) and the function to apply in the recursive case (multiplication).</p>
<blockquote>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">exp</mtext><mo>=</mo><mi>λ</mi><mrow></mrow><mi>x</mi><mo>.</mo><mi>λ</mi><mrow></mrow><mi>y</mi><mo>.</mo><mtext mathvariant="sans-serif">R</mtext><mtext mathvariant="sans-serif">SO</mtext><mo stretchy="false">(</mo><mi>λ</mi><mrow></mrow><mi>z</mi><mo>.</mo><mi>λ</mi><mrow></mrow><mi>w</mi><mo>.</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mtext mathvariant="sans-serif">mult</mtext><mo stretchy="false">)</mo><mi>x</mi><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi>y</mi></mrow></math></p>
</blockquote>
<h2 id="predecessor">Predecessor</h2>
<p>The predecessor function is given by the following equations.</p>
<blockquote>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>P</mi><mi>r</mi><mi>e</mi><mi>d</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>P</mi><mi>r</mi><mi>e</mi><mi>d</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow></math></p>
</blockquote>
<p>Compared to the nested recursions given above, the definition of the predecessor function in <em>T</em> is strikingly simple.</p>
<blockquote>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">pred</mtext><mo>=</mo><mi>λ</mi><mrow></mrow><mi>x</mi><mo>.</mo><mtext mathvariant="sans-serif">RO</mtext><mo stretchy="false">(</mo><mi>λ</mi><mrow></mrow><mi>y</mi><mo>.</mo><mi>λ</mi><mrow></mrow><mi>z</mi><mo>.</mo><mi>z</mi><mo stretchy="false">)</mo><mi>x</mi></mrow></math></p>
</blockquote>
<p>The insight which allows one to derive it is similarly simple. An application of the predecessor function to some successor (in the case of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">O</mtext></mrow></math> the predecessor will simply be <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">O</mtext></mrow></math> too) will be of this form: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">RO</mtext><mo stretchy="false">(</mo><mi>λ</mi><mrow></mrow><mi>y</mi><mo>.</mo><mi>λ</mi><mrow></mrow><mi>z</mi><mo>.</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mtext mathvariant="sans-serif">S</mtext><mi>x</mi><mo stretchy="false">)</mo></mrow></math>. When we look at the reduced term after one reduction, we have something like <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false">(</mo><mi>λ</mi><mrow></mrow><mi>y</mi><mo>.</mo><mi>λ</mi><mrow></mrow><mi>z</mi><mo>.</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mtext mathvariant="sans-serif">RO</mtext><mo stretchy="false">(</mo><mi>λ</mi><mrow></mrow><mi>y</mi><mo>.</mo><mi>λ</mi><mrow></mrow><mi>z</mi><mo>.</mo><mi>z</mi><mo stretchy="false">)</mo><mi>x</mi><mo stretchy="false">)</mo><mi>x</mi></mrow></math>.</p>
<p>Ignore the new occurrence of the recursion operator; just consider it as another term. Instead, look at the whole formula as an application. Clearly, the first argument to the function on the left will always be discarded: the whole term will always reduce simply to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math>, the predecessor of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="sans-serif">S</mtext><mi>x</mi></mrow></math>, our initial argument.</p>
<h2 id="references-further-reading">References &amp; further reading</h2>
<ul>
<li>Girard, Lafont and Taylor’s <a href="http://www.PaulTaylor.EU/stable/Proofs+Types.html"><em>Proofs and Types</em></a> is the primary reference for this article.</li>
<li>System <em>T</em> was first introduced by Kurt Gödel in his 1958 <em>Dialectia</em> article ‘Über eine bisher noch nicht benützte Erweiterung des finiten Standpunktes’, which is reproduced (with an English translation) in volume II of his <a href="http://ukcatalogue.oup.com/product/9780195147216.do"><em>Collected Works</em></a>, edited by Feferman et al.</li>
<li>The more modern version of <em>T</em> which Girard et al. work from was first given by William Tait in his 1967 <a href="http://www.aslonline.org/journals-journal.html"><em>JSL</em></a> article, ‘Intensional interpretation of functionals of finite type I’.</li>
<li>From a programming languages perspective, Benjamin Pierce provides a good introduction to the simply typed lambda calculus in chapter 9 of his book <a href="http://www.cis.upenn.edu/~bcpierce/tapl/"><em>Types and Programming Languages</em></a>.</li>
<li>A more general introduction to the λ-calculus is Hindley and Seldin’s <a href="http://www.cambridge.org/gb/knowledge/isbn/item1175709/"><em>Lambda-Calculus and Combinators</em></a>, while Barendregt’s <a href="http://mathgate.info/cebrown/notes/barendregt.php"><em>The Lambda Calculus: Its Syntax and Semantics</em></a> is the definitive reference work in the field.</li>
</ul>
</article>

    </section>
    
    <footer id="footer" class="wrapper">
        <p>
            Created by <a href="http://folone.info/">Georgii Leontiev</a>.
        </p>
    </footer>
    
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body></html>
